#include <Eigen/Dense>
#include <complex>
#include <pari/pari.h>
#include <algorithm>
#include <iostream>
#include <cassert>
#include <vector>
#include <Eigen/MPRealSupport>

//#include <boost/multiprecision/gmp.hpp> 
//#include <boost/multiprecision/cpp_int.hpp> 
//#include <flint/fmprb_mat.h>
using namespace std;
//using namespace mpfr;
using Eigen::Matrix;
using Eigen::ComplexEigenSolver;
using Eigen::Dynamic;
//using namespace boost::multiprecision;
typedef long long i64;
//typedef mpz_int i64;

#define for_prime_factors(N) for(int p=2; (p*p<=(N) || (p=(N))) && p>1; p++) if((N)%p==0)
int rel_prime[1000];
vector<int> primes_list;
int mobius[500000];
int mobius2[500000];

long long pow(long long x, int y) {
    if(y==0) return 1;
    long long ret = pow(x,y/2);
    ret *= ret;
    return (y%2?ret*x:ret);
}


int pow(int x, int y) {
    if(y==0) return 1;
    long long ret = pow(x,y/2);
    ret *= ret;
    return (y%2?ret*x:ret);
}

int psi(int N) {
    int ret=N;
    for_prime_factors(N) {
        ret = ret * (p+1)/p;
        do { N/=p; } while(N%p==0);
    }
    return ret;
}

int phi(int N) {
    int ret=N;
    for_prime_factors(N) {
        ret = ret * (p-1)/p;
        do { N/=p; } while(N%p==0);
    }
    return ret;
}

int number_of_divisors(int N) {
    int ret=1;
    for_prime_factors(N) {
        int e=0;
        do { N/=p; e++; } while(N%p==0);
        ret *= e+1;
    }
    return ret;
}

int sqfree(int N) {
    int ret=1;
    for_prime_factors(N) {
        int e=0;
        do { N/=p; e++; } while(N%p==0);
        if(e%2==1) ret *= p;
    }
    return ret;
}

int valuation(int N, int p) {
    int ret=0;
    while(N%p==0) N/=p, ret++;
    return ret;
}

// Evaluate the polynomials from the trace formula
// If t^2,n <= M then bounded by Fibonacci_k * M^(k/2)a < (3M)^(k/2)
template<class i64> i64 evalpoly(int k, long long t, long long n) {
    switch(k) {
    case 0: return (i64)1;
    case 1: return (i64)t;
    case 2: return (i64)t*t-n;
    case 3: return (i64)t*t*t-2*t*n;
    case 4: return (i64)t*t*t*t - 3*t*t*n + n*n;
    case 5: return (i64)t*t*t*t*t - 4*t*t*t*n + 3*t*n*n;
    case 10:
        i64 tt = t*t;
        return - n*n*n*n*n + tt * (15*n*n*n*n + tt * (-35*n*n*n + tt * (28*n*n + tt * (-9*n + tt))));
    }

    i64 val[2];
    val[0]=t*t*t*t - 3*t*t*n + n*n;
    val[1]=t*t*t*t*t - 4*t*t*t*n + 3*t*n*n;
    for(int i=6; i<=k; i++) {
        val[i%2] = t*val[(i+1)%2] - n*val[i%2];
    }
    return val[k%2];
}

int classnumbers[10000000];
int classnumber(int D) {
    int& ret = classnumbers[-D];
    if(ret) return ret;
    pari_sp av = avma; ret=itos(classno(stoi(D))); avma = av;
    return ret;
}

double to_double(long long x) { return x; }
//double to_double(const mpz_int& x) { return x.convert_to<double>(); }

// Return a list of pairs (g,e) where (Z/NZ)* is generated by the order e elements g
void gen_and_pow_of_znstar(int N, vector<int>& gens, vector<int>& exps) {
    gens.clear();
    exps.clear();
    pari_sp av = avma;
    GEN zns = znstar(stoi(N));
    int phi = itos(gel(zns,1));
    int ngen = lg(gel(zns,2));
    vector<pair<int,int> > ret;
    for(int i=1; i<ngen; i++) {
	    gens.push_back(itos(gel(gel(gel(zns,3),i),2)));
            exps.push_back(itos(gel(gel(zns,2),i)));
    }
    avma = av;
}

struct enum_znstar {
    vector<int> exps;
    vector<int> gens;
    vector<int> cur_exp;
    int cur_n;
    int N;

    enum_znstar(int _N) : N(_N) {
        gen_and_pow_of_znstar(N, gens, exps);
        cur_exp = vector<int>(exps.size());
        cur_n=1;
    }
    bool next() {
        cur_exp[0]++;
        cur_n = (cur_n * gens[0]) % N;
        for(int i=0; cur_exp[i]>=exps[i]; i++) {
            cur_exp[i]-=exps[i];
            if(i==exps.size()-1) return false;
            cur_exp[i+1]++;
            cur_n = (cur_n * gens[i+1]) % N;
        }
        return true;
    }
    int get() { return cur_n; }
    operator int() { return cur_n; }
    int operator[](int i) {
        return cur_exp[i];
    }
    friend ostream& operator<<(ostream& os, const enum_znstar& v) {
        os << "(" << v.cur_n << " = ";
        for(int i=0; i<v.cur_exp.size(); i++) {
            os << (i?"*":"") << v.gens[i] << "^" << v.cur_exp[i];
        }
        os << " mod " << v.N << ")";
        return os;
    }
};

Matrix<complex<double>,Dynamic,Dynamic> matrix_of_character_exponents(int N, int k) {
    int phiN = phi(N);
    enum_znstar e1(N), e2(N);
    vector<vector<int> > ret(phiN, vector<int>(N));
    int chi=0;
    int nchi=0;
    do {
        do {
            int& cur = ret[chi][e2];
            for(int i=0; i<e1.gens.size(); i++) {
                cur += ((e1.cur_exp[i] * e2.cur_exp[i])%e1.exps[i])*(phiN/e1.exps[i]);
                cur %= phiN;
            }
            cur %= phiN;
        } while(e2.next());
        if(true || ret[chi][N-1]==(k%2?phiN/2:0)) nchi++;
        chi++;
    } while(e1.next());

    Matrix<complex<double>,Dynamic,Dynamic> ret2 = Matrix<complex<double>,Dynamic,Dynamic>::Zero(nchi, N);
    for(int i=0, ii=0; i<phiN; i++) if(true || ret[i][N-1]==(k%2?phiN/2:0)) {
        for(int j=0, jj=0; j<N; j++)
            if(__gcd(N,j)==1)
                ret2.coeffRef(ii,jj++)=polar(1.0, -2*M_PI*(1.*ret[i][j]/phiN));
            else
                ret2.coeffRef(ii,jj++)=0;
        ii++;
    }
    return ret2;
}


//#define pow boost::multiprecision::pow

double theoretical_TrT_bound(int M, int N, int k) {
    return pow(double(12*M),(k-1)/2.)*N*N*log(1+M);
}

template<class i64> Matrix<double,Dynamic,Dynamic> allTrThat12(const int M, const int N, int k) {

    const int phiN = phi(N);
    //vector<vector<i64> > vals(phiN,vector<i64>(M));
    Matrix<double,Dynamic,Dynamic> vals = Matrix<double,Dynamic,Dynamic>::Zero(N,M);
    for(int i=0, j=0; i<N; i++) if(__gcd(i,N)==1) rel_prime[j++]=i;
    rel_prime[phiN]=0;

    int msk = 15;

    // A1
    // Bounded by N^2 k M^(k/2-1)
    int psiN = psi(N);
    if(msk&1) for(int i=0; i<phiN; i++) for(int n=rel_prime[i]; n*n<M; n+=N) {
        vals.coeffRef(rel_prime[i],n*n) += (phiN * psiN * (k-1)) * pow((i64)n, k-2);
    }

    // A2
    // Bounded by (12M)^(k/2-1) * 6N^2 * h(4M) * sqrt(M)/N < (12M)^(k/2) * N * log log M
    int bound=sqrt(4*M)+1;
    if(msk&2) for(int t=0; t<=bound; t++) {
        for(int i=0; i<phiN; i++) {
            int y=rel_prime[i];
            int n = ((t*y-y*y)%N+N)%N;
            n += (t*t/4)/N*N-N;
            while(t*t>=4*n) n+=N;
            for(; n<M; n+=N) {
                int D = -sqfree(4*n-t*t);
                if(D%4==-2 || D%4==-1) D*=4;
                int S2 = classnumber(D);
                int X = round(sqrt((t*t-4*n)/D));
                for_prime_factors(X) {
                    int c=0;
                    do { X/=p; c++; } while(X%p==0);
                    int a = valuation(N, p);
                    int d = valuation(y*y-t*y+n, p);
                    int S3 = 0;
                    int kDp = p-kross(D,p);

                    if(a==0) {
                        S3 = 1+kDp*(pow(p,c)-1)/(p-1);
                    } else {
                        if(d>=2*a && a<=c) S3 = pow(p,a-1)*(p+1)*(1+kDp*(pow(p,c-a)-1)/(p-1));
                        else if(c<=d-a) S3 = pow(p,c);
                        S3 += pow(p,c-1) * kDp * max(0,min(min(c,a),d-a+1));
                    }
                    S2 *= S3;
                }
                S2 *= 6 * phiN;
                if(D==-3) S2/=3;
                else if(D==-4) S2/=2;
                vals.coeffRef(y,n) -= S2*evalpoly<i64>(k-2, t, n);
                if(t>0) vals.coeffRef((N-y)%N,n) -= S2*evalpoly<i64>(k-2, -t, n);
            }
        }
    }

    // A3
    // Bounded by 12*M^(k/2+1/2)*log(M)*log(N)
    if(msk&4) for(int d=1; d<M; d++) {
        for(int n=d; n<min(M,d*d+1); n+=d) {
            i64 p = pow((i64)min(d,n/d),k-1);
            int S2=0;
            for(int i=0; i<phiN; i++) {
                int a=rel_prime[i];
                int c1=N/__gcd(N,abs(n/d-a));
                int c2 = __gcd(N,abs(d-a));
                if(c2%c1==0) {
                    vals.coeffRef(a,n) -= phiN*(d*d==n?6:12)*number_of_divisors(c2/c1)*p;
                }
            }
        }
    }

    // A4
    // Bounded by N^2*log(N)
    if(msk&8) if(k==2) {
        for(int t=1; t<M; t++) {
            for(int i=0; i<phiN; i++) {
                int a = rel_prime[i];
                for(int n=t; n<M; n+=t) {
                    vals.coeffRef(a,n) += 12*t;
                }
            }
        }
    }

    double theoretical_upper_bound = theoretical_TrT_bound(M,N,k);
    double actual_upper_bound = 0;

    for(int a=0; a<phiN; a++) {
        for(int n=1; n<M; n++) {
            //double x = static_cast<double>(vals.coeffRef(a,n));
            double x = to_double(vals.coeffRef(rel_prime[a],n));
            if(x>actual_upper_bound) {
                actual_upper_bound = x;
            }
            vals.coeffRef(rel_prime[a],n) *= 1./phiN/12;
            //if(abs(vals.coeffRef(a,n)) > theoretical_upper_bound) {
                //cout << a << " " << n << " " << vals.coeffRef(a,n) << " " << theoretical_upper_bound << endl;
            //}
            //cout << vals.coeffRef(a,n) << " ";
        }
        //cout << endl;
    }
    cout << theoretical_upper_bound << " theoretical bound vs " << actual_upper_bound << " actual" << endl;
    assert(theoretical_upper_bound > actual_upper_bound);
    //cout << vals.coeffRef(0,0)/(phiN*12) << " " << vals.coeffRef(0,M/2)/(phiN*12) << " " << vals.coeffRef(0,M-1)/(phiN*12) << endl;

    return vals;
}

void allTrThat12new(int M, int N, int k) {
    //for(int d=1; d<=N; d++) if(N%d==1
}

int main(void) {
        pari_init(8000000, 600000);

        cout << "Testing eigenvalues" << endl;
        int MM, prec;
        cin >> MM >> prec;
        mpfr::mpreal::set_default_prec(prec);

        Matrix<complex<mpfr::mpreal>,Dynamic,Dynamic> mat(MM,MM);
        for(int i=0; i<MM; i++) for(int j=0; j<MM; j++)
            mat(i,j) = rand()/65536./65536.;
        ComplexEigenSolver<Matrix<complex<mpfr::mpreal>,Dynamic,Dynamic> > ces(mat);
        cout << ces.eigenvalues() << endl;
        return 0;

        cout << "Initalizing primes" << endl;
        for(int i=1; i<41541; i++) primes_list.push_back(itos(prime(i)));
        cout << "Done" << endl;

        cout << "Computing mobius mu" << endl;
        for(int i=1; i<500000; i++) mobius[i]=mobius2[i]=1;
        int p;
        for(int i=0;; i++) {
            int p = primes_list[i];
            if(p>500000) break;
            for(int i=p; i<500000; i+=p) mobius[i]*=-1;
            for(int i=p; i<500000; i+=p) mobius2[i]*=-2;
        }
        for(int i=0;; i++) {
            int p = primes_list[i];
            if(p*p>500000) break;
            for(int i=p*p; i<500000; i+=p*p) mobius[i]*=0;
            for(int i=p*p; i<500000; i+=p*p) mobius2[i]/=-2;
        }
        for(int i=0;; i++) {
            int p = primes_list[i];
            if(p*p*p>500000) break;
            for(int i=p*p*p; i<500000; i+=p*p*p) mobius2[i]*=0;
        }
        cout << "Done" << endl;

	//gen_and_pow_of_znstar(15);

        //int M=500000, N=997, k=4;
        //int M=2, N=997, k=4;
        int M=1000, N=15, k=4;

        cin >> M >> N >> k;

        if(theoretical_TrT_bound(M,N,k)<1e18) {
            Matrix<double,Dynamic,Dynamic> vals = allTrThat12<long long>(M,N,k);
            Matrix<complex<double>,Dynamic,Dynamic> fourier = matrix_of_character_exponents(N,k);
            //cout << "New and old" << endl << vals << endl << "And fouriered" << endl << fourier * vals << endl;
            for(int d=2; d<=N; d++) if(N%d==0) {
                Matrix<double,Dynamic,Dynamic> vals2 = allTrThat12<long long>(M,N/d,k);
                //cout << "Adjusting with" << endl << vals2 << endl << "and fouriered vals2" << endl;// << fourier * vals2 << endl;
                for(int y=0; y<N; y++) if(true||__gcd(N,y)==1) for(int n=0; n<M; n++) {
                    int prime_to_n_part = d;
                    while(__gcd(prime_to_n_part,n)>1) prime_to_n_part /= __gcd(prime_to_n_part,n);
                    vals(y,n) += mobius2[prime_to_n_part] * mobius[d/prime_to_n_part] * vals2(y%(N/d),n) * phi(N/d) / phi(N);
                }
            }
            Matrix<complex<double>,Dynamic,Dynamic> vals2 = fourier * vals;
            int dim = (int)round(vals2(0,1).real());
            assert(abs(vals2(0,1)-(double)dim)<0.0001);
            cout << "Computing dimension " << dim << " eigenbasis" << endl;
            //cout << vals2 << endl;

            vector<int> rel_primes;
            for(int i=1; rel_primes.size()<dim; i++) if(__gcd(i,2*N)==1) rel_primes.push_back(i);

            Matrix<complex<double>,Dynamic,Dynamic> c(dim,dim), Tp(dim,dim), bb(dim, M/rel_primes.back());
            for(int i=0; i<dim; i++) for(int j=0; j<dim; j++) c(i,j)=vals2(0,rel_primes[i]*rel_primes[j]);
            for(int i=0; i<dim; i++) for(int j=0; j<dim; j++) Tp(i,j)=vals2(0,rel_primes[i]*rel_primes[j]*2);
            for(int i=0; i<dim; i++) for(int j=0; j<M/rel_primes.back(); j++) bb(i,j)=vals2(0,rel_primes[i]*j);
            Matrix<complex<double>,Dynamic,Dynamic> v = c.inverse() * Tp;
            //cout << c << endl;
            //cout << Tp << endl;
            //cout << v << endl;
            ComplexEigenSolver<Matrix<complex<double>,Dynamic,Dynamic> > ces((c.inverse() * Tp));
            //cout << ces.eigenvalues() << endl;
            //cout << ces.eigenvectors() << endl;
            //cout << ces.eigenvectors() * bb << endl;
            //cout << "Just new?" << endl << vals << endl << "And fouriered" << endl << fourier * vals << endl;
            //matrix<double,Dynamic,Dynamic> vals = matrix_of_character_exponents(N,k) * allTrThat12<long long>(M,N,k);
            cout << "Done" << endl;
            cout << M/rel_primes.back() << " coefficients" << endl;

        } else {
            cout << "Calculations would overflow long long, switching to gmp" << endl;
            //allTrThat12<mpz_int>(M,N,k);
        }
        //allTrThat12(2000, 1, 12);
}
